package jet.android2.framework.util;

import java.util.*;
import gerapp.app.*;
import jet.wrappers.base.*;
import jet.wrappers.android.*;
import gerapp.modelo.*;

public class ItemChoiceManager
{
  protected static String nl;
  public static synchronized ItemChoiceManager create(String lineSeparator)
  {
    nl = lineSeparator;
    ItemChoiceManager result = new ItemChoiceManager();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "";
  protected final String TEXT_2 = NL + "package  ";
  protected final String TEXT_3 = ".framework.util;" + NL + "" + NL + "/**" + NL + " * Created by Paulo on 03/11/15." + NL + " */" + NL + "" + NL + "import android.os.Bundle;" + NL + "import android.os.Parcel;" + NL + "import android.support.v4.util.LongSparseArray;" + NL + "import android.support.v4.view.ViewCompat;" + NL + "import android.support.v7.widget.RecyclerView;" + NL + "import android.util.SparseBooleanArray;" + NL + "import android.widget.AbsListView;" + NL + "import android.widget.Checkable;" + NL + "" + NL + "" + NL + "/**" + NL + " * The ItemChoiceManager class keeps track of which positions have been selected.  Note that it" + NL + " * doesn't take advantage of new adapter features to track changes in the underlying data." + NL + " */" + NL + "public class ItemChoiceManager {" + NL + "    //private final String LOG_TAG = MainActivity.class.getSimpleName();" + NL + "    private final String SELECTED_ITEMS_KEY = \"SIK\";" + NL + "    private int mChoiceMode;" + NL + "" + NL + "    private RecyclerView.Adapter mAdapter;" + NL + "    private RecyclerView.AdapterDataObserver mAdapterDataObserver = new RecyclerView.AdapterDataObserver() {" + NL + "        @Override" + NL + "        public void onChanged() {" + NL + "            super.onChanged();" + NL + "            if (mAdapter != null && mAdapter.hasStableIds())" + NL + "                confirmCheckedPositionsById(mAdapter.getItemCount());" + NL + "        }" + NL + "    };" + NL + "" + NL + "    private ItemChoiceManager() {" + NL + "    }" + NL + "" + NL + "    ;" + NL + "" + NL + "    public ItemChoiceManager(RecyclerView.Adapter adapter) {" + NL + "        mAdapter = adapter;" + NL + "    }" + NL + "" + NL + "    /**" + NL + "     * How many positions in either direction we will search to try to" + NL + "     * find a checked item with a stable ID that moved position across" + NL + "     * a data set change. If the item isn't found it will be unselected." + NL + "     */" + NL + "    private static final int CHECK_POSITION_SEARCH_DISTANCE = 20;" + NL + "" + NL + "    /**" + NL + "     * Running state of which positions are currently checked" + NL + "     */" + NL + "    SparseBooleanArray mCheckStates = new SparseBooleanArray();" + NL + "" + NL + "    /**" + NL + "     * Running state of which IDs are currently checked." + NL + "     * If there is a value for a given key, the checked state for that ID is true" + NL + "     * and the value holds the last known position in the adapter for that id." + NL + "     */" + NL + "    LongSparseArray<Integer> mCheckedIdStates = new LongSparseArray<Integer>();" + NL + "" + NL + "    public void onClick(RecyclerView.ViewHolder vh) {" + NL + "        if (mChoiceMode == AbsListView.CHOICE_MODE_NONE)" + NL + "            return;" + NL + "" + NL + "        int checkedItemCount = mCheckStates.size();" + NL + "        int position = vh.getAdapterPosition();" + NL + "" + NL + "        if (position == RecyclerView.NO_POSITION) {" + NL + "            //Log.d(LOG_TAG, \"Unable to Set Item State\");" + NL + "            return;" + NL + "        }" + NL + "" + NL + "        switch (mChoiceMode) {" + NL + "            case AbsListView.CHOICE_MODE_NONE:" + NL + "                break;" + NL + "            case AbsListView.CHOICE_MODE_SINGLE: {" + NL + "                boolean checked = mCheckStates.get(position, false);" + NL + "                if (!checked) {" + NL + "                    for (int i = 0; i < checkedItemCount; i++) {" + NL + "                        mAdapter.notifyItemChanged(mCheckStates.keyAt(i));" + NL + "                    }" + NL + "                    mCheckStates.clear();" + NL + "                    mCheckStates.put(position, true);" + NL + "                    mCheckedIdStates.clear();" + NL + "                    mCheckedIdStates.put(mAdapter.getItemId(position), position);" + NL + "                }" + NL + "                // We directly call onBindViewHolder here because notifying that an item has" + NL + "                // changed on an item that has the focus causes it to lose focus, which makes" + NL + "                // keyboard navigation a bit annoying" + NL + "                mAdapter.onBindViewHolder(vh, position);" + NL + "                break;" + NL + "            }" + NL + "            case AbsListView.CHOICE_MODE_MULTIPLE: {" + NL + "                boolean checked = mCheckStates.get(position, false);" + NL + "                mCheckStates.put(position, !checked);" + NL + "                // We directly call onBindViewHolder here because notifying that an item has" + NL + "                // changed on an item that has the focus causes it to lose focus, which makes" + NL + "                // keyboard navigation a bit annoying" + NL + "                mAdapter.onBindViewHolder(vh, position);" + NL + "                break;" + NL + "            }" + NL + "            case AbsListView.CHOICE_MODE_MULTIPLE_MODAL: {" + NL + "                throw new RuntimeException(\"Multiple Modal not implemented in ItemChoiceManager.\");" + NL + "            }" + NL + "        }" + NL + "    }" + NL + "" + NL + "    /**" + NL + "     * Defines the choice behavior for the RecyclerView. By default, RecyclerViewChoiceMode does" + NL + "     * not have any choice behavior (AbsListView.CHOICE_MODE_NONE). By setting the choiceMode to" + NL + "     * AbsListView.CHOICE_MODE_SINGLE, the RecyclerView allows up to one item to  be in a" + NL + "     * chosen state." + NL + "     *" + NL + "     * @param choiceMode One of AbsListView.CHOICE_MODE_NONE, AbsListView.CHOICE_MODE_SINGLE" + NL + "     */" + NL + "    public void setChoiceMode(int choiceMode) {" + NL + "        if (mChoiceMode != choiceMode) {" + NL + "            mChoiceMode = choiceMode;" + NL + "            clearSelections();" + NL + "        }" + NL + "    }" + NL + "" + NL + "    /**" + NL + "     * Returns the checked state of the specified position. The result is only" + NL + "     * valid if the choice mode has been set to AbsListView.CHOICE_MODE_SINGLE," + NL + "     * but the code does not check this." + NL + "     *" + NL + "     * @param position The item whose checked state to return" + NL + "     * @return The item's checked state" + NL + "     * @see #setChoiceMode(int)" + NL + "     */" + NL + "    public boolean isItemChecked(int position) {" + NL + "        return mCheckStates.get(position);" + NL + "    }" + NL + "" + NL + "    void clearSelections() {" + NL + "        mCheckStates.clear();" + NL + "        mCheckedIdStates.clear();" + NL + "    }" + NL + "" + NL + "    void confirmCheckedPositionsById(int oldItemCount) {" + NL + "        // Clear out the positional check states, we'll rebuild it below from IDs." + NL + "        mCheckStates.clear();" + NL + "" + NL + "        for (int checkedIndex = 0; checkedIndex < mCheckedIdStates.size(); checkedIndex++) {" + NL + "            final long id = mCheckedIdStates.keyAt(checkedIndex);" + NL + "            final int lastPos = mCheckedIdStates.valueAt(checkedIndex);" + NL + "" + NL + "            final long lastPosId = mAdapter.getItemId(lastPos);" + NL + "            if (id != lastPosId) {" + NL + "                // Look around to see if the ID is nearby. If not, uncheck it." + NL + "                final int start = Math.max(0, lastPos - CHECK_POSITION_SEARCH_DISTANCE);" + NL + "                final int end = Math.min(lastPos + CHECK_POSITION_SEARCH_DISTANCE, oldItemCount);" + NL + "                boolean found = false;" + NL + "                for (int searchPos = start; searchPos < end; searchPos++) {" + NL + "                    final long searchId = mAdapter.getItemId(searchPos);" + NL + "                    if (id == searchId) {" + NL + "                        found = true;" + NL + "                        mCheckStates.put(searchPos, true);" + NL + "                        mCheckedIdStates.setValueAt(checkedIndex, searchPos);" + NL + "                        break;" + NL + "                    }" + NL + "                }" + NL + "" + NL + "                if (!found) {" + NL + "                    mCheckedIdStates.delete(id);" + NL + "                    checkedIndex--;" + NL + "                }" + NL + "            } else {" + NL + "                mCheckStates.put(lastPos, true);" + NL + "            }" + NL + "        }" + NL + "    }" + NL + "" + NL + "    public void onBindViewHolder(RecyclerView.ViewHolder vh, int position) {" + NL + "        boolean checked = isItemChecked(position);" + NL + "        if (vh.itemView instanceof Checkable) {" + NL + "            ((Checkable) vh.itemView).setChecked(checked);" + NL + "        }" + NL + "        ViewCompat.setActivated(vh.itemView, checked);" + NL + "    }" + NL + "" + NL + "    public void onRestoreInstanceState(Bundle savedInstanceState) {" + NL + "        byte[] states = savedInstanceState.getByteArray(SELECTED_ITEMS_KEY);" + NL + "        if ( null != states ) {" + NL + "            Parcel inParcel = Parcel.obtain();" + NL + "            inParcel.unmarshall(states, 0, states.length);" + NL + "            inParcel.setDataPosition(0);" + NL + "            mCheckStates = inParcel.readSparseBooleanArray();" + NL + "            final int numStates = inParcel.readInt();" + NL + "            mCheckedIdStates.clear();" + NL + "            for (int i=0; i<numStates; i++) {" + NL + "                final long key = inParcel.readLong();" + NL + "                final int value = inParcel.readInt();" + NL + "                mCheckedIdStates.put(key, value);" + NL + "            }" + NL + "        }" + NL + "    }" + NL + "" + NL + "    public void onSaveInstanceState(Bundle outState) {" + NL + "        Parcel outParcel = Parcel.obtain();" + NL + "        outParcel.writeSparseBooleanArray(mCheckStates);" + NL + "        final int numStates = mCheckedIdStates.size();" + NL + "        outParcel.writeInt(numStates);" + NL + "        for (int i=0; i<numStates; i++) {" + NL + "            outParcel.writeLong(mCheckedIdStates.keyAt(i));" + NL + "            outParcel.writeInt(mCheckedIdStates.valueAt(i));" + NL + "        }" + NL + "        byte[] states = outParcel.marshall();" + NL + "        outState.putByteArray(SELECTED_ITEMS_KEY, states);" + NL + "        outParcel.recycle();" + NL + "    }" + NL + "" + NL + "    public int getSelectedItemPosition() {" + NL + "        if ( mCheckStates.size() == 0 ) {" + NL + "            return RecyclerView.NO_POSITION;" + NL + "        } else {" + NL + "            return mCheckStates.keyAt(0);" + NL + "        }" + NL + "    }" + NL + "}" + NL;
  protected final String TEXT_4 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
    stringBuffer.append(TEXT_1);
    
Recursos recursos = (Recursos) argument;  
ClasseWrapper classe = (ClasseWrapper) recursos.getClasse();
Configuracao conf = recursos.getConfiguracao();

    stringBuffer.append(TEXT_2);
    stringBuffer.append( conf.getNamespaceExtendido() );
    stringBuffer.append(TEXT_3);
    stringBuffer.append(TEXT_4);
    return stringBuffer.toString();
  }
}
